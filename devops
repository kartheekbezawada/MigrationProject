In the current Databricks deployment process, the focus has been on ensuring code quality and system stability as code progresses through the different environments—from development to production. Following best practices in DevOps, it's clear that balancing speed with stability is crucial for a high-performing IT organization. Our existing process provides a solid foundation, but there are opportunities to enhance it further to align with these principles.

Current Process Overview
Development to Staging Deployment:

Code is first merged into the GitHub development branch.
This action triggers an automated pipeline that deploys the code sequentially through the development, testing, and staging environments. This level of automation supports continuous integration and continuous delivery (CI/CD), key practices that help teams deploy changes faster and with fewer errors.
Production Deployment:

For production deployment, code must be merged into the main branch, a step that requires approval from two engineers. This peer review process is essential for ensuring code quality and preventing defects from reaching the production environment.
Once merged, Azure DevOps pipelines are automatically triggered, preparing the code for production.
A change request (CR) must be raised and approved before the final deployment. This CR includes evidence of successful deployments and testing in the lower environments, ensuring that the code is production-ready.
Upon CR approval, a DevOps engineer releases the pipeline, deploying the code into production.
While this process has been effective in maintaining system stability, it lacks the agility needed for frequent deployments, particularly for minor changes. Adopting best practices that emphasize both speed and stability, we see an opportunity to refine our governance to balance control with deployment velocity.

Proposed Governance Changes
The DevOps team has proposed several changes to enhance governance around Databricks deployments, aiming to increase control over the deployment process. However, these changes must be carefully balanced against their potential impact on deployment frequency and development efficiency.

Lead Engineer Approval for Code Changes:

Only Lead Engineers will have the authority to approve code changes or new code before it is merged into the main branch. This ensures that potential issues are caught early, aligning with the principle of shifting left on security and quality.
Developer Merge Restrictions:

The engineer who developed the code will not be permitted to merge it into the GitHub repository. This promotes peer review and maintains a separation of duties, both of which are vital for ensuring code integrity and security.
Mandatory Change Request (CR):

A CR must be raised for production deployment, including:
Evidence of successful deployment in lower environments.
Documentation of thorough testing.
This step ensures that all deployments are well-documented and that the risks are understood and mitigated before reaching production.
DevOps Engineer Merge Responsibility:

Following CR approval, only a DevOps Engineer will merge the code into the main branch, ensuring that those with the right operational expertise manage the final steps before deployment.
DevOps Engineer Pipeline Release:

The release of the pipeline for production deployment will be executed by a DevOps Engineer, maintaining tight control over the final deployment stage.
Final Production Deployment:

Upon completion of these steps, the code will be deployed to the production workspace, ensuring that all quality gates have been passed.
While these proposed changes aim to increase governance, they could slow down deployment frequency and impact development efficiency. Best practices in DevOps highlight the importance of reducing lead times and improving deployment frequency as key indicators of high performance in IT.

Feedback and Suggested Approach
To balance governance with the need for speed and agility, it is recommended to categorize changes into two types: Major and Minor. This approach is consistent with the best practices of making work visible and prioritizing based on impact.

Major Changes:

These changes impact the entire Data Ecosystem Platform or involve significant architectural adjustments.
Major changes should follow the full governance process as proposed, ensuring that high-impact changes are thoroughly vetted and secure.
Minor Changes:

These changes are limited to specific workloads or involve minor modifications.

For minor changes, a streamlined process is recommended:

Pull Request Creation: Engineers create a pull request to the main branch from the release branch, which should include a description of the change and any testing done.
Evidence Submission: Attach evidence of successful testing and deployment in lower environments to the pull request, with relevant documentation or screenshots.
Lead Engineer Approval: Two Lead Engineers review and approve the changes. If approved, the pull request can proceed.
Self-Merge: Once the changes are approved, the engineer who created the pull request may merge the code themselves, promoting autonomy and faster cycles.
Automated Deployment: Azure DevOps pipelines automatically deploy the changes to production, maintaining the speed and efficiency that DevOps aims to achieve.
This approach leverages best practices in DevOps—such as reducing deployment lead times and enabling frequent, low-risk deployments—while maintaining robust governance where it matters most. By distinguishing between major and minor changes, we can ensure that significant changes receive the necessary oversight, while minor updates can be deployed rapidly, thereby improving overall deployment frequency and developer productivity.
